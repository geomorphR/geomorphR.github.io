pleth.gpa <- gpagen(plethodon$land, print.progress = F)
plot(pleth.gpa)
plotAllSpecimens(pleth.gpa$coords, links = plethodon$links)
# Points and Curve points
data(hummingbirds)
hummingbirds$curvepts
gpa.BE <- gpagen(hummingbirds$land, curves=hummingbirds$curvepts, ProcD=FALSE, print.progress = F)
plot(gpa.BE)
gpa.procD <- gpagen(hummingbirds$land, curves=hummingbirds$curvepts, ProcD=TRUE, print.progress = F)
plot(gpa.procD)
# Points, Curves, and Surfaces
data(scallops)
scallops$surfslide
#Using Procrustes Distance for sliding
gpa.scallop <- gpagen(A=scallops$coorddata, curves=scallops$curvslide, surfaces=scallops$surfslide, print.progress = F)
plot(gpa.scallop)
# Plotting all specimens
data(plethodon)
Y.gpa <- gpagen(plethodon$land, print.progress = F)    # GPA-alignment
# PCA
PCA <- gm.prcomp(Y.gpa$coords)
summary(PCA)
plot(PCA)
# More Plotting Options
gps <- as.factor(paste(plethodon$species, plethodon$site))  #define some groups for plotting
plot(PCA, pch=22, cex = 1.5, bg = gps)
legend("topleft", pch=22, pt.bg = unique(gps), legend = levels(gps))
M <- mshape(Y.gpa$coords)
par(mfrow=c(1,2))
plotRefToTarget(M,Y.gpa$coords[,,39], links=plethodon$links)
mtext("TPS")
plotRefToTarget(M,Y.gpa$coords[,,39], mag=2.5, links=plethodon$links)
mtext("TPS: 2.5X magnification")
par(mfrow=c(1,1))
par(mfrow=c(1,2))
plotRefToTarget(M,Y.gpa$coords[,,39], links=plethodon$links, method="vector", mag=3)
mtext("Vector Displacements")
plotRefToTarget(M,Y.gpa$coords[,,39], links=plethodon$links,gridPars=gridPar(pt.bg="red", link.col="green", pt.size = 1), method="vector", mag=3)
mtext("Vector Displacements: Other Options")
par(mfrow=c(1,1))
par(mfrow=c(1,2))
plotRefToTarget(M,Y.gpa$coords[,,39], mag=2, outline=plethodon$outline)
mtext("Outline Deformation")
plotRefToTarget(M,Y.gpa$coords[,,39], method="points", outline=plethodon$outline)
mtext("Outline Deformations Ref (gray) & and Tar (black)")
par(mfrow=c(1,1))
# PCA-based
PC <- PCA$x[,1]
preds <- shape.predictor(Y.gpa$coords, x= PC, Intercept = FALSE,
pred1 = min(PC), pred2 = max(PC)) # PC 1 extremes, more technically
par(mfrow=c(1,2))
plotRefToTarget(M, preds$pred1, links = plethodon$links)
mtext("PC1 - Min.")
plotRefToTarget(M, preds$pred2, links = plethodon$links)
mtext("PC1 - Max.")
par(mfrow=c(1,1))
# via picknplot.shape
pleth.pca.plot <- plot(PCA)
picknplot.shape(pleth.pca.plot)
# Regression-based
gdf <- geomorph.data.frame(Y.gpa)
plethAllometry <- procD.lm(coords ~ log(Csize), data=gdf, print.progress = FALSE)
allom.plot <- plot(plethAllometry,
type = "regression",
predictor = log(gdf$Csize),
reg.type ="PredLine") # make sure to have a predictor
preds <- shape.predictor(plethAllometry$GM$fitted, x= allom.plot$RegScore, Intercept = TRUE,
predmin = min(allom.plot$RegScore),
predmax = max(allom.plot$RegScore))
par(mfrow=c(1,2))
plotRefToTarget(M, preds$predmin, mag=3, links = plethodon$links)
mtext("Regression Min: 3X")
plotRefToTarget(M, preds$predmax, mag=3, links = plethodon$links)
mtext("Regression Max: 3X")
par(mfrow=c(1,1))
# via picknplot.shape (more detail below)
picknplot.shape(allom.plot)
# Group Differences
gdf <- geomorph.data.frame(Y.gpa, species = plethodon$species, site = plethodon$site)
pleth.anova <- procD.lm(coords ~ species*site, data=gdf, print.progress = FALSE)
X <- pleth.anova$X
X # includes intercept; remove for better functioning
X <- X[,-1]
symJord <- c(0,1,0) # design for P. Jordani in sympatry
alloJord <- c(0,0,0) # design for P. Jordani in allopatry
preds <- shape.predictor(arrayspecs(pleth.anova$fitted, 12, 2), x = X, Intercept = TRUE,
symJord=symJord, alloJord=alloJord)
par(mfrow=c(1,2))
plotRefToTarget(M, preds$symJord, links = plethodon$links, mag=2)
mtext("Sympatric P. Jordani: 2X")
plotRefToTarget(M, preds$alloJord, links = plethodon$links, mag=2)
mtext("Allopatric P. Jordani: 2X")
par(mfrow=c(1,1))
# via picknplot.shape (more detail below)
plot.anova <- plot(pleth.anova, type = "PC", pch = 21,
bg = interaction(gdf$species, gdf$site),
asp = 1)
picknplot.shape(plot.anova)
##### 2C: 3D Warping
scallops <- readland.tps("Data/scallops for viz.tps", specID = "ID")
ref <- mshape(scallops)
refmesh <- warpRefMesh(read.ply("Data/glyp02L.ply"),
scallops[,,1], ref, color=NULL, centered=T)
PCA.scallop <- gm.prcomp(scallops)
PC.sc <- PCA.scallop$x[,1]
sc.preds <- shape.predictor(scallops, x= PC.sc, Intercept = FALSE,
pred1 = min(PC.sc), pred2 = max(PC.sc)) # PC 1 extremes, more technically
plotRefToTarget(ref, sc.preds$pred1)
plotRefToTarget(ref, sc.preds$pred2)
plotRefToTarget(ref, sc.preds$pred1, mesh = refmesh, method = "surface", mag = 1)
plotRefToTarget(ref, sc.preds$pred2, mesh = refmesh, method = "surface", mag = 1)
library(geomorph)
library(geiger)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
PCA <- gm.prcomp(Y.gpa$coords, phy = plethspecies$phy,
align.to.phy = FALSE,
GLS = FALSE)
summary(PCA)
PCA$rot # loadings
PCAplot <- plot(PCA, pch = 16, phylo = TRUE)
# Explore shape change in the plot
picknplot.shape(PCAplot)
picknplot.shape(PCAplot, mag = 3)
# In case one wishes to use results for other reasons:
attributes(PCA)
PCA$d
eigen(var(PCA$x), only.values = TRUE)$values
PACA <- gm.prcomp(Y.gpa$coords, phy = plethspecies$phy,
align.to.phy = TRUE,
GLS = FALSE)
summary(PACA)
PACA$rot # loadings
PACAplot <- plot(PACA, pch = 16, phylo = TRUE)
# Explore shape change in the plot
picknplot.shape(PACAplot)
picknplot.shape(PACAplot, mag = 3)
pPCA <- gm.prcomp(Y.gpa$coords, phy = plethspecies$phy,
align.to.phy = FALSE,
GLS = TRUE)
summary(pPCA)
pPCA$rot # loadings
pPCAplot <- plot(pPCA, pch = 16, phylo = TRUE)
# Explore shape change in the plot
picknplot.shape(pPCAplot)
picknplot.shape(pPCAplot, mag = 3)
data("plethShapeFood")
Y.gpa <- gpagen(plethShapeFood$land)
food <- plethShapeFood$food
rownames(food) <- names(Y.gpa$Csize)
PLSfood <- two.b.pls(food, Y.gpa$coords,
iter = 9999)
PLSallometry <- two.b.pls(Y.gpa$Csize, Y.gpa$coords,
iter = 9999)
PLSintegration <- two.b.pls(Y.gpa$coords[1:5,, ],
Y.gpa$coords[8:13,,],
iter = 9999)
summary(PLSfood)
attributes(PLSfood)
foodPlot <- plot(PLSfood, pch = 16)
picknplot.shape(foodPlot)
main = "Sampling distribution of r")
foodPlot <- plot(PLSfood, pch = 16)
picknplot.shape(foodPlot)
hist(PLSfood$random.r, breaks = 50,
col = "olivedrab1",
main = "Sampling distribution of r")
abline(v = PLSfood$r.pls, lwd = 2, col = "skyblue4")
summary(PLSallometry)
allomPlot <- plot(PLSallometry, pch = 16)
picknplot.shape(allomPlot)
compare.pls(PLSfood,
PLSallometry,
PLSintegration)
fit.null <- procD.lm(coords ~ 1, data = Y.gpa,
iter = 9999)
fit.alt <- procD.lm(coords ~ log(Csize), data = Y.gpa,
iter = 9999)
model.matrix(fit.null)
coef(fit.null)
fitted(fit.null)
resid(fit.null)
model.matrix(fit.alt)
coef(fit.alt)
fitted(fit.alt)
resid(fit.alt)
## Hypothesis tests
coef(fit.alt, test = TRUE)
fit.alt <- procD.lm(coords ~ log(Csize), data = Y.gpa,
turbo = FALSE,
iter = 9999,
Parallel = TRUE)
coef(fit.alt, test = TRUE)
anova(fit.null, fit.alt)
anova(fit.alt)
attributes(fit.alt)
data(pupfish)
plotAllSpecimens(pupfish$coords)  #NOTE: already GPA-aligned
#Y.gpa <- gpagen(pupfish$coords, print.progress = FALSE)    #GPA-alignment
pupfish$logSize <- log(pupfish$CS)
pupfish$Group <- interaction(pupfish$Pop, pupfish$Sex)
fit <- procD.lm(coords ~ logSize, data = pupfish, print.progress = FALSE)
anova(fit)
#plots
plot(fit, type = "regression", reg.type = "PredLine", predictor = pupfish$logSize, pch = 19)
plot(fit, type = "regression", reg.type = "RegScore", predictor = pupfish$logSize, pch = 19)
plotAllometry(fit, size = pupfish$logSize, logsz = FALSE, method = "CAC", pch = 19)
plotAllometry(fit, size = pupfish$logSize, logsz = FALSE, method = "CAC", pch = 19)
M <- mshape(pupfish$coords)
preds <- shape.predictor(fit$GM$fitted, x= pupfish$logSize, Intercept = TRUE,
predmin = min(pupfish$logSize),
predmax = max(pupfish$logSize))
par(mfrow=c(1,2))
plotRefToTarget(M, preds$predmin, mag=1)
mtext("Regression Min")
plotRefToTarget(M, preds$predmax, mag=1)
mtext("Regression Max")
par(mfrow=c(1,1))
## 2B: Group allometry
fit.common <- procD.lm(coords ~ logSize + Group,
data = pupfish, print.progress = FALSE)
fit.unique <- procD.lm(coords ~ logSize * Group,
data = pupfish, print.progress = FALSE)
anova(fit.unique)
### Pairwise Comparisons
slope.pw <- pairwise(fit.unique, fit.null = fit.common,
groups = pupfish$Group,
covariate = pupfish$logSize, print.progress = FALSE)
summary(slope.pw, test.type = "VC", angle.type = "deg") # angular differences
summary(slope.pw, test.type = "dist", angle.type = "deg") # amount of shape change differences
par(mfcol = c(1,2))
plot(fit.common, type = "regression", predictor = pupfish$logSize,
reg.type = "PredLine", pch=19, col = pupfish$Group)
legend("topleft", legend = unique(pupfish$Group), pch = 21, pt.bg = unique(pupfish$Group))
mtext("Common Slopes")
plot(fit.unique, type = "regression", predictor = pupfish$logSize,
reg.type = "PredLine", pch=19, col = pupfish$Group)
legend("topleft", legend = unique(pupfish$Group), pch = 21, pt.bg = unique(pupfish$Group))
mtext("Unique Slopes")
par(mfcol = c(1,1))
data(pupfish) # GPA already performed
fit0 <- procD.lm(coords ~ 1, data = pupfish, iter = 999)
fit1 <- procD.lm(coords ~ log(CS), data = pupfish, iter = 999)
fit2 <- procD.lm(coords ~ Sex, data = pupfish, iter = 999)
fit3 <- procD.lm(coords ~ Pop, data = pupfish, iter = 999)
fit4 <- procD.lm(coords ~ log(CS) + Sex, data = pupfish, iter = 999)
fit5 <- procD.lm(coords ~ log(CS) + Pop, data = pupfish, iter = 999)
fit6 <- procD.lm(coords ~ log(CS) * Sex, data = pupfish, iter = 999)
fit7 <- procD.lm(coords ~ log(CS) * Pop, data = pupfish, iter = 999)
fit8 <- procD.lm(coords ~ Sex * Pop, data = pupfish, iter = 999)
fit9 <- procD.lm(coords ~ log(CS) + Sex*Pop, data = pupfish, iter = 999)
fit10 <- procD.lm(coords ~ log(CS) * Sex*Pop, data = pupfish, iter = 999)
model.matrix(fit0)
coef(fit0)
model.matrix(fit1)
coef(fit1)
model.matrix(fit2)
coef(fit2)
model.matrix(fit3)
coef(fit3)
unique(model.matrix(fit2)) %*% coef(fit2)[,1:4]
model.matrix(fit2) %*% coef(fit2)[,1:4]
fitted(fit2)[, 1:4]
anova(fit8, effect.type = "Rsq")
anova(fit8, effect.type = "F")
reveal.model.designs(fit8)
fitm <- manova.update(fit8)
summary(fitm)
summary(fitm, test = "Pillai")
group <- interaction(pupfish$Pop, pupfish$Sex)
PW <- pairwise(fit8, groups = group)
summary(PW)
summary(PW, stat.table = FALSE)
coef(fit10)[, 1:2]
# Analyses
group <- interaction(pupfish$Pop, pupfish$Sex)
PW <- pairwise(fit10, groups = group,
covariate = log(pupfish$CS))
summary(PW)
summary(PW, test.type = "VC")
summary(PW, test.type = "VC", angle.type = "deg")
TA <- trajectory.analysis(fit8, group = pupfish$Pop,
traj.pts = pupfish$Sex)
summary(TA)
summary(TA, attribute = "TC")
TP <- plot(TA, pch = as.numeric(Pupfish$Pop) + 20, bg = as.numeric(Pupfish$Sex),
cex = 0.7, col = "gray")
add.trajectories(TP, traj.pch = c(21, 22), start.bg = 1, end.bg = 2)
legend("topright", levels(Pupfish$Pop), pch =  c(21, 22), pt.bg = 1)
PW <- pairwise(fit8, groups = group)
summary(PW, test.type = "var")
modComp1 <- model.comparison(fit1, fit2, fit3, fit4, fit5,
fit6, fit7, fit8, fit9, fit10, type = "cov.trace")
modComp2 <- model.comparison(fit1, fit2, fit3, fit4, fit5,
fit6, fit7, fit8, fit9, fit10, type = "logLik", tol = 0.01)
summary(modComp1)
summary(modComp2)
plot(modComp1)
plot(modComp2)
### Read and prune/match data
plethtree <- read.tree('Data/plethtree.tre')
plethtree <- read.tree('Data/plethtree.tre')
plethland <- readland.tps('Data/PlethodonLand.tps',specID = "ID",
warnmsg = FALSE)
gps <- read.csv('Data/PlethGps.csv', header=TRUE, row.names=1)
Y.gpa <- gpagen(plethland, print.progress = FALSE)
M <- mshape(Y.gpa$coords)
svl <- Y.gpa$Csize
shape <- Y.gpa$coords
shape.test <- treedata(phy = plethtree, data = two.d.array(shape), warnings = TRUE)
data.matched <- treedata(phy = plethtree, data = gps, warnings=FALSE)
elev <- as.factor(data.matched$data); names(elev) <- row.names(data.matched$data)
gdf <- geomorph.data.frame(shape=shape, svl=svl,elev = elev, plethtree=plethtree)
links <- matrix(c(4,3,2,1,1,6,7,8,9,10,1,1,11,5,5,4,2,3,7,8,9,10,11,9,10,1),
ncol=2,byrow=FALSE)
plot(ladderize(plethtree),edge.width=3)
axisPhylo(1)
### 1A: Phylogenetic Regression
pgls.reg <- procD.pgls(f1 = shape~svl, phy=plethtree, data=gdf, print.progress = FALSE)
summary(pgls.reg)
plot(pgls.reg)
#Plots
allom.plot <- plot(pgls.reg, type = "regression", predictor = gdf$svl,
reg.type ="RegScore", pch=19, cex=1.5, xlab = "SVL") # make sure to have a predictor
fit.line <- lm(allom.plot$RegScore~gdf$svl)
abline(fit.line,col = "red")
preds <- shape.predictor(pgls.reg$GM$pgls.fitted, x= allom.plot$RegScore, Intercept = FALSE,
predmin = min(allom.plot$RegScore),
predmax = max(allom.plot$RegScore))
M <- mshape(shape)
par(mfrow = c(1,2))
plotRefToTarget(M, preds$predmin, mag=3, links = links)
mtext("Min")
plotRefToTarget(M, preds$predmax, mag=3, links = links)
mtext("Max")
par(mfrow = c(1,1))
### 1B: Phylogenetic ANOVA
pgls.aov <- procD.pgls(f1 = shape~elev, phy=plethtree, data=gdf, print.progress = FALSE)
summary(pgls.aov)
# Plots
plot.res <- gm.prcomp(shape,phy=plethtree)
plot(plot.res,phylo = FALSE, pch=21, bg=gdf$elev, cex=2)
legend("topleft", pch=21, pt.bg = unique(gdf$elev), legend = levels(gdf$elev))
Low <- c(1) # design for low elevation
High <- c(0) # design for high elevation
preds <- shape.predictor(arrayspecs(pgls.aov$pgls.fitted, 11, 2), x = pgls.aov$X[,-1],
Intercept = TRUE, Low = Low, High = High)
par(mfrow=c(1,2))
plotRefToTarget(M, preds$Low, mag=2, links=links)
mtext("Low Elevation")
plotRefToTarget(M, preds$High, mag=2, links=links)
mtext("High Elevation")
par(mfrow=c(1,1))
### 2: Phylogenetic PLS
land.gps<-c("A","A","A","A","A","B","B","B","B","B","B")
PLS.Y <- phylo.integration(A = gdf$shape, partition.gp = land.gps, phy= plethtree, print.progress = FALSE)
summary(PLS.Y)
plot(PLS.Y)
### 3: Phylogenetic Signal
PS.shape <- physignal(A=shape,phy=plethtree,iter=999, print.progress = FALSE)
summary(PS.shape)
plot(PS.shape)
#### Phylomorphospace
plot.pca <- gm.prcomp(shape,phy=plethtree)
plot(plot.pca,phylo = TRUE, pch=21, bg=gdf$elev, cex=2, phylo.par = list(tip.labels = FALSE, node.labels = FALSE) )
legend("topleft", pch=21, pt.bg = unique(gdf$elev), legend = levels(gdf$elev))
#### Phylogenetic PCA (pPCA)
plot.ppca <- gm.prcomp(shape,phy=plethtree, GLS = TRUE, transform = FALSE)
plot(plot.ppca,phylo = TRUE, pch=21, bg=gdf$elev, cex=2, phylo.par = list(tip.labels = FALSE, node.labels = FALSE) )
legend("topleft", pch=21, pt.bg = unique(gdf$elev), legend = levels(gdf$elev))
#### Phylogenetically-Aligned Components Analysis (PACA)
plot.paca <- gm.prcomp(shape,phy=plethtree, align.to.phy = TRUE)
plot(plot.paca,phylo = TRUE, pch=21, bg=gdf$elev, cex=2, phylo.par = list(tip.labels = FALSE, node.labels = FALSE) )
legend("topleft", pch=21, pt.bg = unique(gdf$elev), legend = levels(gdf$elev))
#### Side by Side
par(mfrow=c(1,3))
plot(plot.pca,phylo = TRUE, pch=21, bg=gdf$elev, cex=2, phylo.par = list(tip.labels = FALSE, node.labels = FALSE), main = "Phylomorphospace" )
legend("topleft", pch=21, pt.bg = unique(gdf$elev), legend = levels(gdf$elev))
plot(plot.ppca,phylo = TRUE, pch=21, bg=gdf$elev, cex=2, phylo.par = list(tip.labels = FALSE, node.labels = FALSE), main = "pPCA" )
legend("topleft", pch=21, pt.bg = unique(gdf$elev), legend = levels(gdf$elev))
plot(plot.paca,phylo = TRUE, pch=21, bg=gdf$elev, cex=2, phylo.par = list(tip.labels = FALSE, node.labels = FALSE), main = "PACA" )
legend("topleft", pch=21, pt.bg = unique(gdf$elev), legend = levels(gdf$elev))
par(mfrow=c(1,1))
#### 5A: Comparing Rates Among Clades
ER<-compare.evol.rates(A=gdf$shape, phy=plethtree,gp=gdf$elev,iter=999, method = 'permutation',print.progress = FALSE)
summary(ER)
plot(ER)
#### 5B: Comparing Rates Among Traits
EMR <- compare.multi.evol.rates(A=gdf$shape, phy=plethtree, gp=c(rep(1,5),rep(2,6)), print.progress = FALSE)
summary(EMR)
plot(EMR)
## matching symmetry
data(mosquito)
Y.gpa <- gpagen(mosquito$wingshape, print.progress = FALSE)
plot(Y.gpa)
mosquito.sym <- bilat.symmetry(A = Y.gpa, ind = mosquito$ind, side=mosquito$side,
object.sym = FALSE, print.progress = FALSE)
summary(mosquito.sym)
## object symmetry
data('lizards')
Y.gpa <- gpagen(lizards$coords, print.progress = FALSE)
plot(Y.gpa)
lizard.sym <- bilat.symmetry(A = Y.gpa, ind = lizards$ind, replicate = lizards$rep,
object.sym = TRUE, land.pairs = lizards$lm.pairs, print.progress = FALSE)
summary(lizard.sym)
plot(lizard.sym, warpgrids = TRUE)
#### Comparison of overall vs. symmetrized aligned shapes
plotAllSpecimens(Y.gpa$coords)
plotAllSpecimens(lizard.sym$symm.shape)
## 7: Integration and Modularity
## Overall Integration
data("plethodon")
Y.gpa <- gpagen(plethodon$land, print.progress = FALSE)
#Separate data by species
coords.gp <- coords.subset(Y.gpa$coords, plethodon$species)
#Z_Vrel by species
Vrel.gp <- Map(function(x) integration.Vrel(x), coords.gp)
compare.ZVrel(Vrel.gp$Jord, Vrel.gp$Teyah)
## Integration Across Spatial Scales
globalIntegration(Y.gpa$coords) #data are not spatially integrated
## Integration Among Subsets
data(pupfish) # GPA previously performed
group <- factor(paste(pupfish$Pop, pupfish$Sex, sep = "."))
# Subset 3D array by group, returning a list of 3D arrays
tail.LM <- c(1:3, 5:9, 18:38)
head.LM <- (1:56)[-tail.LM]
tail.coords <- pupfish$coords[tail.LM,,]
head.coords <- pupfish$coords[head.LM,,]
IT <- integration.test(tail.coords, head.coords, print.progress = F)
summary(IT)
plot(IT)
land.gp <- rep(1,56); land.gp[tail.LM] <- 2
integration.test(pupfish$coords, partition.gp=land.gp, print.progress = FALSE)
two.b.pls(tail.coords, head.coords, print.progress = FALSE)
## Comparing the Strength of Integration
tail.coords.gp <- coords.subset(tail.coords, group)
head.coords.gp <- coords.subset(head.coords, group)
# Obtain Integration for groups
integ.tests <- Map(function(x,y) integration.test(x, y, iter=499,
print.progress = FALSE), head.coords.gp, tail.coords.gp)
compare.pls(integ.tests)
## Tests of Modularity
MT <- modularity.test(pupfish$coords,land.gp,CI=FALSE,print.progress = FALSE)
summary(MT)
plot(MT)
## Comparing the Strength of Modularity
coords.gp <- coords.subset(pupfish$coords, group)
modul.tests <- Map(function(x) modularity.test(x, land.gp,print.progress = FALSE), coords.gp)
compare.CR(modul.tests, CR.null = FALSE)
## Comparing Alternative Modular Partitions
land.gps3 <- rep('a',56); land.gps3[39:48]<-'b'; land.gps3[c(6:9,28:38)] <- 'c'
#3 module hypothesis (tail now a module)
land.gps4 <- rep('a',56); land.gps4[39:48]<-'b'; land.gps4[c(6:9,28:38)] <- 'c';
land.gps4[c(10,49:56)] <- 'd'  #4 module hypothesis (eye now a module)
m3.test <- modularity.test(coords.gp$Marsh.F,land.gps3, iter = 499, print.progress = FALSE)
m4.test <- modularity.test(coords.gp$Marsh.F,land.gps4, iter = 499, print.progress = FALSE)
model.Z <- compare.CR(m3.test,m4.test, CR.null = TRUE)
model.Z
data(pupfish) # GPA already performed
TA <- trajectory.analysis(fit8, group = pupfish$Pop,
traj.pts = pupfish$Sex)
summary(TA)
summary(TA, attribute = "TC")
TP <- plot(TA, pch = as.numeric(Pupfish$Pop) + 20, bg = as.numeric(Pupfish$Sex),
cex = 0.7, col = "gray")
add.trajectories(TP, traj.pch = c(21, 22), start.bg = 1, end.bg = 2)
legend("topright", levels(Pupfish$Pop), pch =  c(21, 22), pt.bg = 1)
data(motionpaths)
fit <- procD.lm(trajectories ~ groups, data = motionpaths, iter = 999, print.progress = FALSE)
anova(fit)
TA <- trajectory.analysis(fit, groups = motionpaths$groups, traj.pts = 5)
summary(TA, attribute = "MD") # Magnitude difference (absolute difference between path distances)
summary(TA, attribute = "TC", angle.type = "deg") # Correlations (angles) between trajectories
summary(TA, attribute = "SD") # Shape differences between trajectories
TP <- plot(TA, pch = 21, bg = as.numeric(motionpaths$groups),
cex = 0.7, col = "gray")
add.trajectories(TP, traj.pch = 21, traj.bg = 1:4)
data("pupfish")
Group <- pupfish$Group <- interaction(pupfish$Pop, pupfish$Sex)
fit <- procD.lm(coords ~ Group, data = pupfish)
# Via pairwise
PW <- pairwise(fit, groups = Group)
summary(PW, test.type = "var")
# Via morphol.disparity
MD <- morphol.disparity(fit, print.progress = FALSE)
summary(MD)
MD <- morphol.disparity(coords ~ Group, group = Group,
data = pupfish,
print.progress = FALSE)
P <- plot(fit, type = "PC", pch = 21, bg = pupfish$Group)
shapeHulls(P, Group, group.cols = c(1,3,2,4))
picknplot.shape(P)
fit0 <- procD.lm(coords ~ 1, data = pupfish)
MD2 <- morphol.disparity(fit0, groups = Group,
partial = TRUE,
print.progress = FALSE)
summary(MD2)
P <- plot(fit, type = "PC")
PC <- P$PC.points[, 1:2]
for(i in 1 : nrow(PC))
arrows(0, 0, PC[i,1], PC[i,2],
col = pupfish$Group[i], length = 0.1)
library(StereoMorph)
library(geomorph)
# Landmark digtizing: see Tutorial for additional instructions
digitizeImages(image.file='Data/Fish-Images', shapes.file='Data/Fish-Shapes',
landmarks.ref=paste("LM", c(1:5), sep=""))
library(StereoMorph)
library(geomorph)
# Landmark digtizing: see Tutorial for additional instructions
digitizeImages(image.file='Data/Fish-Images', shapes.file='Data/Fish-Shapes',
landmarks.ref=paste("LM", c(1:5), sep=""))
